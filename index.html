<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã‚·ãƒ³ãƒ—ãƒ«è¨˜æ†¶ 2 (APK Edition)</title>
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* åŸºæœ¬ãƒªã‚»ãƒƒãƒˆ */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        :root {
            --primary-color: #A8FFC1; 
            --tab-1: #FFE4E6; --tab-2: #FFF1E0; --tab-3: #FEFFD6;
            --tab-4: #E6FFED; --tab-5: #E8F4FF; --tab-6: #F3E8FF;
            --tab-7: #F0F0F0; --tab-8: #E0FFE0; --tab-9: #FFF0E0;
        }

        html, body { height: 100%; margin: 0; padding: 0; width: 100%; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f5f5f5;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* èƒŒæ™¯å›ºå®šãƒ¬ã‚¤ãƒ¤ãƒ¼ */
        #bgLayer {
            position: fixed;
            top: -5%;
            left: 0;
            width: 100%;
            height: 110%;
            z-index: -1;
            background-repeat: no-repeat;
            background-position: center;
            background-size: cover;
            pointer-events: none;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            will-change: transform;
        }

        /* å›ºå®šãƒ˜ãƒƒãƒ€ãƒ¼ */
        .fixed-top {
            position: fixed; top: 0; left: 0; right: 0;
            background: rgba(255, 255, 255, 0.98); 
            z-index: 1000; border-bottom: 3px solid var(--primary-color);
        }
        
        .header-main {
            display: flex; align-items: center; justify-content: space-between;
            padding: 4px 10px; height: 48px;
        }
        .app-title { font-size: 16px; font-weight: bold; color: #333; margin: 0; }
        .header-icons { display: flex; gap: 8px; }
        .icon-btn { 
            background: #fff; border: 1px solid #ccc;
            border-radius: 6px; width: 38px; height: 38px;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; color: #444; cursor: pointer;
        }

        /* 9ã‚¿ãƒ–ã‚°ãƒªãƒƒãƒ‰ */
        .tab-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; padding: 4px 8px 8px; }
        .tab {
            padding: 8px 2px; border-radius: 6px; font-size: 0.8rem; 
            border: 1px solid #ccc; text-align: center; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            background: #fff; min-height: 34px;
        }
        .tab:nth-child(1) { background: var(--tab-1); } .tab:nth-child(2) { background: var(--tab-2); }
        .tab:nth-child(3) { background: var(--tab-3); } .tab:nth-child(4) { background: var(--tab-4); }
        .tab:nth-child(5) { background: var(--tab-5); } .tab:nth-child(6) { background: var(--tab-6); }
        .tab:nth-child(7) { background: var(--tab-7); } .tab:nth-child(8) { background: var(--tab-8); }
        .tab:nth-child(9) { background: var(--tab-9); }
        .tab.active { border: 2px solid #333; filter: brightness(0.9); }

        .search-container { padding: 0 8px 8px; }
        #searchInput { 
            width: 100%; padding: 10px 12px; border-radius: 6px; font-size: 15px;
            border: 1px solid #bbb; outline: none; background: #fff;
        }

        #memoList { padding-bottom: 140px; width: 100%; }
        
        .memo-item {
            display: flex; align-items: center; 
            margin: 0; padding: 8px 10px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            background: rgba(255, 255, 255, 0.9);
            min-height: 54px; width: 100%;
        }
        .memo-item:nth-child(even) { background: rgba(248, 248, 248, 0.9); }

        .drag-handle { cursor: grab; color: #999; font-size: 20px; display: none; padding-right: 12px; }
        .memo-item.sort-mode .drag-handle { display: block; }
        .memo-item.dragging { opacity: 0.5; }

        .date-text { font-size: 0.7rem; color: #777; min-width: 75px; flex-shrink: 0; font-family: monospace; }
        .memo-body { 
            flex: 1; font-size: 0.95rem; color: #111; 
            margin: 0 10px; white-space: pre-wrap; word-break: break-all;
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
        }

        .memo-item.editing { flex-wrap: wrap; background: #fffde7 !important; padding: 15px; }
        .memo-item.editing .memo-body { 
            display: block; -webkit-line-clamp: unset; flex-basis: 100%; margin: 10px 0; padding: 12px;
            background: #fff; border: 2px solid #007bff; border-radius: 6px;
            max-height: 350px; overflow-y: auto; outline: none;
        }
        .memo-controls { display: flex; gap: 6px; flex-shrink: 0; }
        .action-btn { border: 1px solid #ccc; background: #fff; font-size: 0.8rem; font-weight: bold; padding: 8px 12px; border-radius: 6px; }
        .btn-delete { color: #d00; border-color: #faa; background: #fff0f0; display: none; }
        .memo-item.editing .btn-delete { display: block; }

        .input-container {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: #f8f8f8; padding: 12px; display: flex; gap: 10px; border-top: 1px solid #bbb; z-index: 1000;
        }
        #memoInput { flex: 1; padding: 12px; border-radius: 8px; border: 1px solid #ccc; font-size: 16px; outline: none; resize: none; max-height: 150px; }
        .add-btn { background: #28a745; color: white; border: none; padding: 0 20px; border-radius: 8px; font-weight: bold; cursor: pointer; }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 2000; align-items: center; justify-content: center; }
        .modal-content { background: white; width: 90%; max-width: 340px; border-radius: 12px; padding: 25px; text-align: center; }
        .modal-btn { width: 100%; margin-bottom: 12px; padding: 14px; border-radius: 8px; border: 1px solid #ccc; cursor: pointer; background: white; font-weight: bold; }
    </style>
</head>
<body>

<div id="bgLayer"></div>

<div class="fixed-top" id="headerArea">
    <div class="header-main">
        <h1 class="app-title" id="displayTitle">èª­ã¿è¾¼ã¿ä¸­...</h1>
        <div class="header-icons">
            <button class="icon-btn" onclick="toggleSortMode()"><i class="fa-solid fa-arrow-right-arrow-left" style="transform: rotate(90deg);"></i></button>
            <button class="icon-btn" onclick="openModal('dataModal')"><i class="fa-solid fa-floppy-disk"></i></button>
            <button class="icon-btn" onclick="openModal('bgModal')"><i class="fa-regular fa-image"></i></button>
        </div>
    </div>
    <div class="tab-grid" id="tabList"></div>
    <div class="search-container"><input type="text" id="searchInput" placeholder="æ¤œç´¢ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›..."></div>
</div>

<div id="memoList"></div>

<div class="input-container" id="inputArea">
    <textarea id="memoInput" placeholder="æ–°ã—ã„ãƒ¡ãƒ¢ã‚’å…¥åŠ›..." rows="1"></textarea>
    <button class="add-btn" onclick="addMemo()">è¿½åŠ </button>
</div>

<div id="bgModal" class="modal"><div class="modal-content"><h3>èƒŒæ™¯è¨­å®š</h3><button class="modal-btn" onclick="triggerBgPicker()">ç”»åƒã‚’é¸æŠ</button><button class="modal-btn" onclick="adjustBgOffset()">ä¸Šä¸‹ä½ç½®ã‚’å¾®èª¿æ•´</button><button class="modal-btn" onclick="clearBg()">èƒŒæ™¯ã‚’å‰Šé™¤</button><button class="modal-btn" style="background:#eee" onclick="closeModal('bgModal')">é–‰ã˜ã‚‹</button></div></div>

<div id="dataModal" class="modal">
    <div class="modal-content">
        <h3>ãƒ‡ãƒ¼ã‚¿ç®¡ç†</h3>
        <button class="modal-btn" onclick="exportData()">ğŸ“‹ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼</button>
        <button class="modal-btn" onclick="showExportData()">ğŸ“„ ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤º (æ‰‹å‹•ã‚³ãƒ”ãƒ¼)</button>
        <button class="modal-btn" onclick="triggerImport()">ğŸ“‚ ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å¾©å…ƒ</button>
        <button class="modal-btn" onclick="importFromClipboard()">ğŸ“‹ è²¼ã‚Šä»˜ã‘ã¦å¾©å…ƒ</button>
        <button class="modal-btn" style="background:#eee" onclick="closeModal('dataModal')">é–‰ã˜ã‚‹</button>
    </div>
</div>

<input type="file" id="bgPicker" accept="image/*" style="display:none">
<input type="file" id="importPicker" accept=".txt,.json" style="display:none">

<script>
    'use strict';
    let currentTabIndex = 0, isSortMode = false, tabNames = [], draggedElement = null, db;
    const DB_NAME = 'SimpleMemoDB_App2', DB_VERSION = 1;

    const DB = {
        open() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const d = e.target.result;
                    if (!d.objectStoreNames.contains('settings')) d.createObjectStore('settings');
                    if (!d.objectStoreNames.contains('memos')) d.createObjectStore('memos');
                    if (!d.objectStoreNames.contains('backgrounds')) d.createObjectStore('backgrounds');
                };
                request.onsuccess = (e) => { db = e.target.result; resolve(); };
                request.onerror = (e) => reject(e);
            });
        },
        get: (s, k, d) => new Promise(res => {
            const tx = db.transaction(s, 'readonly');
            const req = tx.objectStore(s).get(k);
            req.onsuccess = () => res(req.result !== undefined ? req.result : d);
            req.onerror = () => res(d);
        }),
        set: (s, k, v) => new Promise(res => {
            const tx = db.transaction(s, 'readwrite');
            tx.objectStore(s).put(v, k).onsuccess = () => res(true);
        }),
        delete: (s, k) => new Promise(res => {
            const tx = db.transaction(s, 'readwrite');
            tx.objectStore(s).delete(k).onsuccess = () => res(true);
        })
    };

    const Utils = {
        formatDate: (d) => `${d.getMonth()+1}/${d.getDate()} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`,
        genId: () => Date.now() + Math.random().toString(36).substr(2, 6)
    };

    async function init() {
        if ('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js').catch(() => {});
        await DB.open();
        let stored = await DB.get('settings', 'tabNames', []);
        const defaults = ["ã‚«ãƒ†ã‚´ãƒª 1", "ã‚«ãƒ†ã‚´ãƒª 2", "ã‚«ãƒ†ã‚´ãƒª 3", "ã‚«ãƒ†ã‚´ãƒª 4", "ã‚«ãƒ†ã‚´ãƒª 5", "ã‚«ãƒ†ã‚´ãƒª 6", "ã‚«ãƒ†ã‚´ãƒª 7", "ã‚«ãƒ†ã‚´ãƒª 8", "ã‚«ãƒ†ã‚´ãƒª 9"];
        tabNames = (stored.length < 9) ? stored.concat(defaults.slice(stored.length)) : stored;
        if (stored.length < 9) await DB.set('settings', 'tabNames', tabNames);
        renderTabs(); await loadMemos(); await applyBgImage(); setupEvents(); setTimeout(adjustLayout, 300);
    }

    function setupEvents() {
        document.getElementById('bgPicker').onchange = handleBgSelect;
        document.getElementById('importPicker').onchange = handleFileImport;
        const input = document.getElementById('memoInput');
        input.oninput = function() { this.style.height = 'auto'; this.style.height = Math.min(this.scrollHeight, 150) + 'px'; adjustLayout(); };
        const list = document.getElementById('memoList');
        list.addEventListener('dragover', e => {
            if (!isSortMode) return;
            e.preventDefault();
            const after = [...list.querySelectorAll('.memo-item:not(.dragging)')].find(s => e.clientY < s.getBoundingClientRect().top + s.offsetHeight/2);
            list.insertBefore(draggedElement, after);
        });
        document.getElementById('searchInput').oninput = filterMemos;
        window.addEventListener('resize', adjustLayout);
    }

    function adjustLayout() {
        const header = document.getElementById('headerArea'), list = document.getElementById('memoList'), input = document.getElementById('inputArea');
        if (header && list) {
            list.style.marginTop = header.offsetHeight + 'px';
            if (input) list.style.paddingBottom = (input.offsetHeight + 60) + 'px';
        }
    }

    async function applyBgImage() {
        const d = await DB.get('backgrounds', `bg-t${currentTabIndex}`, null);
        const o = await DB.get('settings', `off-t${currentTabIndex}`, "0");
        const layer = document.getElementById('bgLayer');
        layer.style.backgroundImage = d ? `url("${d}")` : "none";
        layer.style.backgroundPosition = `center calc(50% + ${o}px)`;
    }

    async function loadMemos() {
        const list = document.getElementById('memoList'); list.innerHTML = '';
        const data = await DB.get('memos', `t${currentTabIndex}`, []);
        if (!data.length) { list.innerHTML = `<div style="text-align:center; padding:100px 20px; color:#999;">ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</div>`; }
        else { data.forEach(m => renderMemo(m, list)); }
        adjustLayout();
    }

    function renderMemo(m, targetList) {
        const div = document.createElement('div');
        div.className = `memo-item ${isSortMode ? 'sort-mode' : ''}`;
        div.id = `m-${m.id}`; div.draggable = isSortMode;
        div.innerHTML = `
            <div class="drag-handle"><i class="fa-solid fa-bars"></i></div>
            <span class="date-text">${m.date}</span>
            <div class="memo-body">${m.text.replace(/</g,'&lt;')}</div>
            <div class="memo-controls">
                <button class="action-btn" onclick="copyText('${m.id}')">Copy</button>
                <button class="action-btn" onclick="toggleEdit('${m.id}')">ç·¨é›†</button>
                <button class="action-btn btn-delete" onclick="deleteMemo('${m.id}')">å‰Šé™¤</button>
            </div>`;
        if (isSortMode) {
            div.ondragstart = () => { draggedElement = div; div.classList.add('dragging'); };
            div.ondragend = async () => { div.classList.remove('dragging'); draggedElement = null; await saveOrder(); };
        }
        targetList.appendChild(div);
    }

    async function addMemo() {
        const input = document.getElementById('memoInput'), text = input.value.trim();
        if (!text) return;
        const data = await DB.get('memos', `t${currentTabIndex}`, []);
        data.unshift({ id: Utils.genId(), text, date: Utils.formatDate(new Date()) });
        await DB.set('memos', `t${currentTabIndex}`, data);
        input.value = ''; input.style.height = 'auto'; await loadMemos(); 
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    async function toggleEdit(id) {
        const el = document.getElementById(`m-${id}`), body = el.querySelector('.memo-body'), btn = el.querySelectorAll('.action-btn')[1];
        if (!el.classList.contains('editing')) {
            el.classList.add('editing'); body.contentEditable = true; body.focus(); btn.textContent = "å®Œäº†";
        } else {
            el.classList.remove('editing'); body.contentEditable = false; btn.textContent = "ç·¨é›†";
            const data = await DB.get('memos', `t${currentTabIndex}`, []);
            const m = data.find(x => String(x.id) === String(id));
            if (m) { m.text = body.innerText.trim(); await DB.set('memos', `t${currentTabIndex}`, data); }
            await loadMemos();
        }
    }

    async function deleteMemo(id) {
        if (!confirm('æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
        let data = await DB.get('memos', `t${currentTabIndex}`, []);
        data = data.filter(m => String(m.id) !== String(id));
        await DB.set('memos', `t${currentTabIndex}`, data); await loadMemos();
    }

    function copyText(id) {
        const text = document.querySelector(`#m-${id} .memo-body`).innerText;
        navigator.clipboard.writeText(text).then(() => { 
            const btn = document.querySelector(`#m-${id} .action-btn`);
            const old = btn.textContent; btn.textContent = "OK!";
            setTimeout(() => btn.textContent = old, 1000);
        });
    }

    async function toggleSortMode() { isSortMode = !isSortMode; await loadMemos(); }
    async function saveOrder() {
        const ids = [...document.querySelectorAll('.memo-item')].map(el => el.id.replace('m-',''));
        const old = await DB.get('memos', `t${currentTabIndex}`, []);
        const sorted = ids.map(id => old.find(m => String(m.id) === String(id))).filter(Boolean);
        await DB.set('memos', `t${currentTabIndex}`, sorted);
    }

    function renderTabs() {
        const list = document.getElementById('tabList'); list.innerHTML = '';
        tabNames.forEach((name, i) => {
            const btn = document.createElement('div');
            btn.className = `tab ${i === currentTabIndex ? 'active' : ''}`; 
            btn.textContent = name;
            btn.onclick = async () => { currentTabIndex = i; isSortMode = false; renderTabs(); await applyBgImage(); await loadMemos(); window.scrollTo(0, 0); };
            btn.oncontextmenu = (e) => { e.preventDefault(); renameTab(i); };
            list.appendChild(btn);
        });
        document.getElementById('displayTitle').textContent = tabNames[currentTabIndex];
    }

    async function renameTab(i) {
        const n = prompt("åå‰ã‚’å¤‰æ›´:", tabNames[i]);
        if (n && n.trim()) { tabNames[i] = n.trim(); await DB.set('settings', 'tabNames', tabNames); renderTabs(); adjustLayout(); }
    }

    function openModal(id) { document.getElementById(id).style.display = 'flex'; }
    function closeModal(id) { document.getElementById(id).style.display = 'none'; }
    function triggerBgPicker() { closeModal('bgModal'); document.getElementById('bgPicker').click(); }

    async function handleBgSelect(e) {
        const file = e.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            const img = new Image();
            img.onload = async () => {
                const canvas = document.createElement('canvas');
                let w = img.width, h = img.height, max = 1600;
                if (w > max || h > max) { if (w > h) { h = (h * max) / w; w = max; } else { w = (w * max) / h; h = max; } }
                canvas.width = w; canvas.height = h;
                canvas.getContext('2d').drawImage(img, 0, 0, w, h);
                await DB.set('backgrounds', `bg-t${currentTabIndex}`, canvas.toDataURL('image/jpeg', 0.8));
                await applyBgImage();
            };
            img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    }

    async function adjustBgOffset() {
        const cur = await DB.get('settings', `off-t${currentTabIndex}`, "0");
        const val = prompt("ä½ç½®èª¿æ•´ (px):", cur);
        if (val !== null && !isNaN(val)) { await DB.set('settings', `off-t${currentTabIndex}`, val); await applyBgImage(); }
    }

    async function clearBg() { if(confirm("å‰Šé™¤ï¼Ÿ")) { await DB.delete('backgrounds', `bg-t${currentTabIndex}`); await applyBgImage(); closeModal('bgModal'); } }

    // --- APKç’°å¢ƒå¯¾å¿œ: ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰æ‰‹å‹•ä¿å­˜æ–¹å¼ ---
    async function exportData() {
        try {
            const all = { tabs: tabNames, contents: {} };
            for(let i=0; i<9; i++) {
                all.contents[`tab_${i}`] = await DB.get('memos', `t${i}`, []);
            }
            const jsonString = JSON.stringify(all);

            // APKç’°å¢ƒã§ã¯ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ”ãƒ¼ãŒæœ€ã‚‚ç¢ºå®Ÿ
            try {
                await navigator.clipboard.writeText(jsonString);
                alert("âœ“ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ!\n\nãƒ¡ãƒ¢å¸³ã‚„ãƒ¡ãƒ¼ãƒ«ãªã©ã«è²¼ã‚Šä»˜ã‘ã¦ä¿å­˜ã—ã¦ãã ã•ã„ã€‚");
                closeModal('dataModal');
                return;
            } catch (err) {
                console.error('Clipboard copy error:', err);
                alert("ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nä»¥ä¸‹ã®æ–¹æ³•ã‚’ãŠè©¦ã—ãã ã•ã„:\n\n1. åˆ¥ã®ã‚¢ãƒ—ãƒªã‚’é–‰ã˜ã¦ã‹ã‚‰å†åº¦è©¦ã™\n2. ã€ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã€ãƒœã‚¿ãƒ³ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤ºã—ã¦æ‰‹å‹•ã‚³ãƒ”ãƒ¼");
            }
        } catch (err) {
            console.error('Export error:', err);
            alert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
        }
    }

    // --- APKç’°å¢ƒå¯¾å¿œ: ãƒ‡ãƒ¼ã‚¿ã‚’ç”»é¢ã«è¡¨ç¤ºã—ã¦æ‰‹å‹•ã‚³ãƒ”ãƒ¼ ---
    async function showExportData() {
        try {
            const all = { tabs: tabNames, contents: {} };
            for(let i=0; i<9; i++) {
                all.contents[`tab_${i}`] = await DB.get('memos', `t${i}`, []);
            }
            const jsonString = JSON.stringify(all);
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤º
            const modal = document.getElementById('exportModal');
            if (!modal) {
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
                const newModal = document.createElement('div');
                newModal.id = 'exportModal';
                newModal.className = 'modal';
                newModal.innerHTML = `
                    <div class="modal-content" style="max-width: 90%; max-height: 80vh; overflow-y: auto;">
                        <h3>ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿</h3>
                        <p style="font-size: 0.8rem; color: #666;">ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’é•·æŠ¼ã—ã—ã¦ã€ã‚³ãƒ”ãƒ¼ã€ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
                        <textarea readonly style="width: 100%; height: 300px; padding: 10px; border: 1px solid #ccc; border-radius: 6px; font-family: monospace; font-size: 0.7rem;">${jsonString}</textarea>
                        <button class="modal-btn" onclick="copyExportText()">ã‚³ãƒ”ãƒ¼</button>
                        <button class="modal-btn" style="background:#eee" onclick="closeModal('exportModal')">é–‰ã˜ã‚‹</button>
                    </div>
                `;
                document.body.appendChild(newModal);
            } else {
                // æ—¢å­˜ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’æ›´æ–°
                const textarea = modal.querySelector('textarea');
                if (textarea) textarea.value = jsonString;
            }
            
            closeModal('dataModal');
            openModal('exportModal');
        } catch (err) {
            console.error('Show export error:', err);
            alert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
        }
    }

    // --- ãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºãƒ¢ãƒ¼ãƒ€ãƒ«ã‹ã‚‰ã®ã‚³ãƒ”ãƒ¼ ---
    function copyExportText() {
        const textarea = document.querySelector('#exportModal textarea');
        if (textarea) {
            textarea.select();
            document.execCommand('copy');
            alert("âœ“ ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ!");
        }
    }

    function triggerImport() { closeModal('dataModal'); document.getElementById('importPicker').click(); }

    async function importFromClipboard() {
        try {
            // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰èª­ã¿è¾¼ã¿
            const text = await navigator.clipboard.readText();
            if (!text) {
                alert("ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ãŒç©ºã§ã™ã€‚\n\nãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚");
                return;
            }
            
            try {
                const d = JSON.parse(text);
                await processImportData(d);
            } catch(e) {
                alert("å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚\n\nãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒæ­£ã—ãã‚³ãƒ”ãƒ¼ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
            }
        } catch (err) {
            console.error('Clipboard read error:', err);
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: prompt ã‚’ä½¿ç”¨
            const text = prompt("ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’ã“ã“ã«è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„:");
            if (!text) return;
            try {
                const d = JSON.parse(text);
                await processImportData(d);
            } catch(e) {
                alert("å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“");
            }
        }
    }

    function handleFileImport(e) {
        const f = e.target.files[0]; if (!f) return;
        const r = new FileReader();
        r.onload = async (ev) => {
            try {
                const d = JSON.parse(ev.target.result);
                await processImportData(d);
            } catch(e) { alert("å¤±æ•—"); }
        };
        r.readAsText(f);
    }

    async function processImportData(d) {
        if (!confirm("ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒï¼ˆä¸Šæ›¸ãï¼‰ã—ã¾ã™ã‹ï¼Ÿ")) return;
        try {
            await DB.set('settings', 'tabNames', d.tabs);
            for(let i=0; i<9; i++) await DB.set('memos', `t${i}`, d.contents[`tab_${i}`] || []);
            alert("å¾©å…ƒå®Œäº†ã—ã¾ã—ãŸã€‚å†èµ·å‹•ã—ã¾ã™ã€‚");
            location.reload();
        } catch(e) { alert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"); }
    }

    function filterMemos() {
        const q = document.getElementById('searchInput').value.toLowerCase();
        document.querySelectorAll('.memo-item').forEach(el => { el.style.display = el.innerText.toLowerCase().includes(q) ? 'flex' : 'none'; });
        adjustLayout();
    }

    init();
</script>
</body>
</html>
